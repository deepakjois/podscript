package ytt

import (
	"context"
	"fmt"
	"os"
	"path"
	"regexp"
	"strings"
	"time"

	"github.com/deepakjois/ytt"
	"github.com/spf13/cobra"
	"github.com/tmc/langchaingo/llms"
)

const (
	userPrompt = `You will be given auto-generated captions from a YouTube video. These may be full captions, or a segment of the full transcript if it is too large. Your task is to transform these captions into a clean, readable transcript. Here are the auto-generated captions:

<captions>
%s
</captions>

Follow these steps to create a clean transcript:

1. Correct any spelling errors you encounter. Use your knowledge of common words and context to determine the correct spelling.

2. Add appropriate punctuation throughout the text. This includes commas, periods, question marks, and exclamation points where necessary.

3. Capitalize the first letter of each sentence and proper nouns.

4. Break the text into logical paragraphs. Start a new paragraph when there's a shift in topic or speaker.

5. Remove any unnecessary filler words, repetitions, or false starts.

6. Maintain the original meaning and intent of the transcript. Do not remove any content even if it is unrelated to the main topic.


Once you have completed these steps, provide the clean transcript within <transcript> and </transcript> tags. Ensure that the transcript is well-formatted, easy to read, 
and accurately represents the original content of the video. Do not include any additional text in your response.`
)

var transcriptRegex = regexp.MustCompile(`(?s)<transcript>(.*?)</transcript>`)

func extractTranscript(input string) string {
	match := transcriptRegex.FindStringSubmatch(input)
	if len(match) > 1 {
		return strings.TrimSpace(match[1])
	}
	return ""
}

type transcriptCleaner struct {
	modelOpt Model
	model    llms.Model
}

func newTranscriptCleaner(model Model) (*transcriptCleaner, error) {
	llm, err := getModel(model)
	if err != nil {
		return nil, err
	}
	return &transcriptCleaner{modelOpt: model, model: llm}, nil
}

func (tc transcriptCleaner) cleanupTranscript(transcript string) (string, error) {
	chunks, err := splitText(transcript, tc.modelOpt)

	if err != nil {
		return "", fmt.Errorf("error splitting text: %w", err)
	}

	var cleanedTranscript strings.Builder
	for i, chunk := range chunks {
		cleanedChunk, err := llms.GenerateFromSinglePrompt(
			context.Background(),
			tc.model, userPrompt+"\n\n"+chunk,
			llms.WithMaxTokens(maxTokens[tc.modelOpt]),
		)
		if err != nil {
			return "", fmt.Errorf("failed to process chunk: %w", err)
		}
		fmt.Println(cleanedChunk)
		cleanedChunk = extractTranscript(cleanedChunk)
		cleanedTranscript.WriteString(cleanedChunk)
		fmt.Printf("transcribed part %d/%dâ€¦\n", i+1, len(chunks))
	}
	return cleanedTranscript.String(), nil
}

var Command = &cobra.Command{
	Use:   "ytt <youtube_url>",
	Short: "Generate cleaned up transcript from YouTube autogenerated captions using ChatGPT",
	Args:  cobra.ExactArgs(1),
	PreRunE: func(cmd *cobra.Command, args []string) error {
		raw, _ := cmd.Flags().GetBool("raw")
		if raw {
			return nil
		}

		model, _ := cmd.Flags().GetString("model")
		switch model {
		case string(ChatGPT4o), string(ChatGpt4oMini), string(Claude3Dot5Sonnet20240620), string(GroqLlama3170B):
			return nil
		default:
			return fmt.Errorf("invalid model: must be one of %s, %s or %s", ChatGpt4oMini, ChatGPT4o, Claude3Dot5Sonnet20240620)
		}
	},
	RunE: func(cmd *cobra.Command, args []string) error {
		raw, _ := cmd.Flags().GetBool("raw")

		folder, _ := cmd.Flags().GetString("path")
		suffix, _ := cmd.Flags().GetString("suffix")
		if folder != "" {
			fi, err := os.Stat(folder)
			if err != nil || !fi.IsDir() {
				return fmt.Errorf("path not found: %s", folder)
			}
		}
		timestamp := time.Now().Format("2006-01-02-150405")
		var filenameSuffix string
		if suffix == "" {
			filenameSuffix = timestamp
		} else {
			filenameSuffix = fmt.Sprintf("%s_%s", timestamp, suffix)
		}

		// Extract Transcript
		videoID, err := ytt.ExtractVideoID(args[0])
		if err != nil {
			return fmt.Errorf("failed to extract video ID: %w", err)
		}

		transcriptList, err := ytt.ListTranscripts(videoID)
		if err != nil {
			return fmt.Errorf("failed to list transcripts: %w", err)
		}

		transcript, err := transcriptList.FindTranscript("en")
		if err != nil {
			return fmt.Errorf("failed to find English transcript: %w", err)
		}

		entries, err := transcript.Fetch()
		if err != nil {
			return fmt.Errorf("failed to fetch transcript: %w", err)
		}

		var transcriptTxt strings.Builder
		for _, entry := range entries {
			transcriptTxt.WriteString(" " + entry.Text)
		}

		rawTranscriptFilename := path.Join(folder, fmt.Sprintf("raw_transcript_%s.txt", filenameSuffix))
		if err = os.WriteFile(rawTranscriptFilename, []byte(transcriptTxt.String()), 0644); err != nil {
			return fmt.Errorf("failed to write raw transcript: %w", err)
		}
		fmt.Printf("wrote raw autogenerated captions to %s\n", rawTranscriptFilename)

		// Stop if only raw transcript required
		if raw {
			return nil
		}

		// Initialize API client
		m, _ := cmd.Flags().GetString("model")
		model := Model(m)
		tc, err := newTranscriptCleaner(model)
		if err != nil {
			return fmt.Errorf("failed to initialize model %s: %v", model, err)
		}

		cleanedTranscriptTxt, err := tc.cleanupTranscript(transcriptTxt.String())
		if err != nil {
			return fmt.Errorf("failed to transcribe: %w", err)
		}

		cleanedTranscriptFilename := path.Join(folder, fmt.Sprintf("cleaned_transcript_%s.txt", filenameSuffix))
		if err = os.WriteFile(cleanedTranscriptFilename, []byte(cleanedTranscriptTxt), 0644); err != nil {
			return fmt.Errorf("failed to write cleaned transcript: %w", err)
		}
		fmt.Printf("wrote cleaned up transcripts to %s\n", cleanedTranscriptFilename)
		return nil
	},
}

func init() {
	Command.Flags().StringP("path", "p", "", "save raw and cleaned up transcripts to path")
	Command.Flags().StringP("suffix", "s", "", "append suffix to filenames")
	Command.Flags().BoolP("raw", "r", false, "download raw transcript, don't cleanup using LLM")
	Command.Flags().StringP("model", "m", string(ChatGpt4oMini), fmt.Sprintf("use model - one of %s (default if ommitted), %s, %s or %s", ChatGpt4oMini, ChatGPT4o, Claude3Dot5Sonnet20240620, GroqLlama3170B))
	Command.MarkFlagsMutuallyExclusive("raw", "model")

}
