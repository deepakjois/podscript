package ytt

import (
	"bufio"
	"errors"
	"fmt"
	"os"
	"path"
	"regexp"
	"strings"
	"time"

	"github.com/kkdai/youtube/v2"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

const (
	userPrompt = `You will be given auto-generated captions from a YouTube video. These may be full captions, or a segment of the full transcript if it is too large. Your task is to transform these captions into a clean, readable transcript. Here are the auto-generated captions:

<captions>
%s
</captions>

Follow these steps to create a clean transcript:

1. Correct any spelling errors you encounter. Use your knowledge of common words and context to determine the correct spelling.

2. Add appropriate punctuation throughout the text. This includes commas, periods, question marks, and exclamation points where necessary.

3. Capitalize the first letter of each sentence and proper nouns.

4. Break the text into logical paragraphs. Start a new paragraph when there's a shift in topic or speaker.

5. Remove any unnecessary filler words, repetitions, or false starts.

6. Maintain the original meaning and intent of the transcript. Do not remove any content even if it is unrelated to the main topic.


Once you have completed these steps, provide the clean transcript within <transcript> tags. Ensure that the transcript is well-formatted, easy to read, 
and accurately represents the original content of the video. Do not include any additional text in your response.`
)

var transcriptRegex = regexp.MustCompile(`(?s)<transcript>(.*?)</transcript>`)

func extractTranscript(input string) string {
	match := transcriptRegex.FindStringSubmatch(input)
	if len(match) > 1 {
		return strings.TrimSpace(match[1])
	}
	return ""
}

func calcWordsFromTokens(tokens int) int {
	// round down to nearest 1000
	return int((float64(tokens)*0.75)/1000) * 1000
}

var maxWordsPerChunk map[Model]int = map[Model]int{
	ChatGPT4o:                 calcWordsFromTokens(maxTokens[ChatGPT4o]),
	ChatGpt4oMini:             calcWordsFromTokens(maxTokens[ChatGpt4oMini]),
	Claude3Dot5Sonnet20240620: calcWordsFromTokens(maxTokens[Claude3Dot5Sonnet20240620]),
}

func chunkTranscript(transcript string, maxWordsPerChunk int) []string {
	// Split the transcript into chunks
	var chunks []string
	scanner := bufio.NewScanner(strings.NewReader(transcript))
	scanner.Split(bufio.ScanWords)

	var chunkBuilder strings.Builder
	wordCount := 0

	for scanner.Scan() {
		word := scanner.Text()
		chunkBuilder.WriteString(word + " ")
		wordCount++
		if wordCount >= maxWordsPerChunk {
			chunks = append(chunks, chunkBuilder.String())
			chunkBuilder.Reset()
			wordCount = 0
		}
	}
	if chunkBuilder.Len() > 0 {
		chunks = append(chunks, chunkBuilder.String())
	}
	return chunks

}

var Command = &cobra.Command{
	Use:   "ytt <youtube_url>",
	Short: "Generate cleaned up transcript from YouTube autogenerated captions using ChatGPT",
	Args:  cobra.ExactArgs(1),
	PreRunE: func(cmd *cobra.Command, args []string) error {
		raw, _ := cmd.Flags().GetBool("raw")
		if raw {
			return nil
		}

		model, _ := cmd.Flags().GetString("model")
		switch model {
		case string(ChatGPT4o), string(ChatGpt4oMini), string(Claude3Dot5Sonnet20240620):
			return nil
		default:
			return fmt.Errorf("invalid model: must be one of %s, %s or %s", ChatGpt4oMini, ChatGPT4o, Claude3Dot5Sonnet20240620)
		}
	},
	RunE: func(cmd *cobra.Command, args []string) error {
		raw, _ := cmd.Flags().GetBool("raw")

		var (
			model Model
			tc    TranscriptCleaner
		)
		if !raw {
			model = Model(cmd.Flags().Lookup("model").Value.String())
			switch model {
			case ChatGPT4o, ChatGpt4oMini:
				openaiApiKey := viper.GetString("openai_api_key")
				if openaiApiKey == "" {
					return errors.New("OpenAI API key not found. Please run 'podscript configure' or set the PODSCRIPT_OPENAI_API_KEY environment variable")
				}
				tc = NewOpenAITranscriptCleaner(openaiApiKey, model)

			case Claude3Dot5Sonnet20240620:
				anthropicApiKey := viper.GetString("anthropic_api_key")
				if anthropicApiKey == "" {
					return errors.New("Anthropic API key not found. Please run 'podscript configure' or set the PODSCRIPT_ANTHROPIC_API_KEY environment variable")
				}
				tc = NewAnthropicTranscriptCleaner(anthropicApiKey)
			default:
				// Should never get here
				panic(fmt.Sprintf("Cannot initialise API client from model %s", model))
			}
		}

		folder, _ := cmd.Flags().GetString("path")
		suffix, _ := cmd.Flags().GetString("suffix")
		if folder != "" {
			fi, err := os.Stat(folder)
			if err != nil || !fi.IsDir() {
				return fmt.Errorf("path not found: %s", folder)
			}
		}
		timestamp := time.Now().Format("2006-01-02-150405")
		var filenameSuffix string
		if suffix == "" {
			filenameSuffix = timestamp
		} else {
			filenameSuffix = fmt.Sprintf("%s_%s", timestamp, suffix)
		}

		// Extract Transcript
		youtubeClient := youtube.Client{}

		video, err := youtubeClient.GetVideo(args[0])
		if err != nil {
			return fmt.Errorf("failed to get video info: %w", err)
		}

		transcript, err := youtubeClient.GetTranscript(video, "en")
		if err != nil {
			return fmt.Errorf("failed to get transcript info: %w", err)
		}

		var transcriptTxt string
		for _, tr := range transcript {
			transcriptTxt += tr.Text + "\n"
		}

		rawTranscriptFilename := path.Join(folder, fmt.Sprintf("raw_transcript_%s.txt", filenameSuffix))
		if err = os.WriteFile(rawTranscriptFilename, []byte(transcriptTxt), 0644); err != nil {
			return fmt.Errorf("failed to write raw transcript: %w", err)
		}
		fmt.Printf("wrote raw autogenerated captions to %s\n", rawTranscriptFilename)

		// Stop if only raw transcript required
		if raw {
			return nil
		}

		// Chunk and Send to LLM API
		chunks := chunkTranscript(transcriptTxt, maxWordsPerChunk[model])

		var cleanedTranscript strings.Builder
		for i, chunk := range chunks {
			cleanedChunk, err := tc.CleanupTranscript(chunk)
			if err != nil {
				return fmt.Errorf("failed to process chunk: %w", err)
			}
			cleanedChunk = extractTranscript(cleanedChunk)
			cleanedTranscript.WriteString(cleanedChunk)
			fmt.Printf("transcribed part %d/%dâ€¦\n", i+1, len(chunks))
		}

		cleanedTranscriptFilename := path.Join(folder, fmt.Sprintf("cleaned_transcript_%s.txt", filenameSuffix))
		if err = os.WriteFile(cleanedTranscriptFilename, []byte(cleanedTranscript.String()), 0644); err != nil {
			return fmt.Errorf("failed to write cleaned transcript: %w", err)
		}
		fmt.Printf("wrote cleaned up transcripts to %s\n", cleanedTranscriptFilename)
		return nil
	},
}

func init() {
	Command.Flags().StringP("path", "p", "", "save raw and cleaned up transcripts to path")
	Command.Flags().StringP("suffix", "s", "", "append suffix to filenames")
	Command.Flags().BoolP("raw", "r", false, "download raw transcript, don't cleanup using LLM")
	Command.Flags().StringP("model", "m", string(ChatGpt4oMini), fmt.Sprintf("use model - one of %s (default if ommitted), %s or %s", ChatGpt4oMini, ChatGPT4o, Claude3Dot5Sonnet20240620))
	Command.MarkFlagsMutuallyExclusive("raw", "model")

}
